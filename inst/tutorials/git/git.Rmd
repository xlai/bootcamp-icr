---
title: "Version Control with Git"
author: "Xiaoran Lai"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = TRUE)

# Any setup R code can go here
library(dplyr)
# Etc

```


## Welcome

By the end of this training, you will be equipped with the foundational knowledge and skills necessary to effectively use Git for version control in your projects.

### Learning Objectives
Upon completion of this session, you will:

* Understand the Importance of Version Control
* Learn Basic Git Commands:
  - `clone` a git repository;
  - Make and `commit` some changes;
  - Make those changes available to others by using the `push` command;
  - Fetch other people's changes using the `pull` command;
* Explore Branching and Merging
* Collaborate Using Git
* Resolve simple conflicts
* Adopt best practices for using git at ICR-CTSU to manage the analysis directory for a trial.


## Introduction to Version Control Systems (VCS)
VCS are tools that help track changes to files and code over time, particularly valuable for maintaining the integrity of statistical analyses and data management.
![](https://swcarpentry.github.io/git-novice/fig/phd101212s.png)

Importance of Version Control in Clinical Trials:

- Collaboration
- Data Integrity
- Compliance and Auditing
- Efficient Development

## Introduction to git

[git](https://git-scm.com/) is a distributed VCS used to track changes in source code.
It enables statisticians to work together on statistical analysis plans, datasets, and code.

How Git Works in a Clinical Trial Context:

- Managing Code and Documents
- Branching for Analysis Scenarios
- Reproducibility

Why Git in Clinical Trials:

- Traceability
- Integration with Statistical workflow
- Enhanced Collaboration among cross-functional trial teams

Git is primarily designed to work with text-based files, and it excels at tracking changes, merging content, and resolving conflicts in these types of files. 

But what is a _text-based_ file?

```{r text-based, echo = FALSE}
quiz(
  
  question("An R script with extension `R`",
    answer("Yes", correct = TRUE),
    answer("No", correct = FALSE)
  ),
  
  question("A Stata script with extension `do`",
    answer("Yes", correct = TRUE),
    answer("No", correct = FALSE)
  ),
  
  question("A text file with extension `txt`",
    answer("Yes", correct = TRUE),
    answer("No", correct = FALSE)
  ),
  
  question("An image with extension `png`",
    answer("Yes", correct = FALSE),
    answer("No", correct = TRUE)
  ),
  
  question("A LaTeX input file with extension `tex`",
    answer("Yes", correct = TRUE),
    answer("No", correct = FALSE)
  ),
  
  question("A PDF file (with extension `pdf`)",
    answer("Yes", correct = FALSE),
    answer("No", correct = TRUE)
  ),
  
  question("A Word document with extension `doc`",
    answer("Yes", correct = FALSE),
    answer("No", correct = TRUE)
  ),
  
  question("An Excel sheet with extension `xls`",
    answer("Yes", correct = FALSE),
    answer("No", correct = TRUE)
  ),
  
  question("A web-page with extension `html`",
    answer("Yes", correct = TRUE),
    answer("No", correct = FALSE)
  ),
  
  question("A zip file with extension `zip`",
    answer("Yes", correct = FALSE),
    answer("No", correct = TRUE)
  ),
  
  question("A Word document with extension `docx`",
    answer("Yes", correct = TRUE),
    answer("No", correct = FALSE)
  ),
  
  question("An Excel sheet with extension `xlsx`",
    answer("Yes", correct = TRUE),
    answer("No", correct = FALSE)
  )
  
)
```

N.B: Modern MS Office formats are xml-based, making them technically text-based.

## Installing git

You can find the latest installation guide [here](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)

- Windows: If you are planning to use git in windows powershell, download and install from [here](https://git-scm.com/download/win); 
if you intend to use Windowss Subsystem for Linux (WSL), please follow the linux installation guide.

- Mac: Git should be pre-installed already. You can check by trying to run `git` from the Terminal with 

```
git --version
```

- Linux: If you on a Debian-based distribution (*i.e.* Ubuntu), you can install it with

```
sudo apt install git-all
```

If you are on Fedora or other RPM-based distribution (RHEL for example), use the following

```
sudo dnf install git-all
```

## Command line basics

The command line is a text-based interface used to interact with your computer's operating system.
Many Git operations are performed using command-line instructions. 

Understanding the command line is essential for efficiently using Git.

- Windows:

    a. Command Prompt or PowerShell: Windows users can use Command Prompt or PowerShell for command-line operations.
    b. Basic Commands:

        - `dir`: List files and directories.
        - `cd [directory name]`: Change the current directory.
        - `git --version`: Check the installed Git version.

- Mac and Linux:

    a. Terminal: Mac and Linux users typically use the Terminal for command-line operations.
    b. Basic Commands (Same for Both):
    
        - `ls`: List files and directories.
        - `cd [directory name]`: Change the current directory.
        - `git --version`: Check the installed Git version.


***
Tips:

  - Tab Completion: Use the Tab key to auto-complete file and directory names.
  - Up/Down Arrow Keys: Navigate previous commands.

## Understanding Git Repositories

### Configuring git

To set your global commit name and email address run the `git config` command with the `--global` option:

```
git config --global user.name "Your Name"
git config --global user.email "youremail@yourdomain.com"
```

### Initializing a Git Repository

#### what is a repository
`git` is used to track changes in a directory.
A directory being tracked is generally referred to as a _repository_ or a _repo_.
It is a virtual storage of your project. 
It allows you to save versions of your code, which you can access when needed.

There are two types of repositories:

- **Local** Repository: Stored on your computer for personal use.
- **Remote** Repository: Stored on a server, facilitating collaboration with others (e.g., GitHub, GitLab).

Within the local repository, there are three main components:

  - Working Directory: Where files are created and edited.
  - Staging Area (Index): An intermediate area where changes are listed before committing.
  - Git Directory (Repository): Where Git stores the metadata and object database for the project.

**Commits** describes how changes are saved as 'commits,' each with a unique identifier.

Remote Repository enables team collaboration by allowing multiple people to push and pull changes.
  
  - Forks and Clones:
    
    a. 'forking' a repository is to create a personal copy on the server
    b. 'cloning' is to download the repository to your local machine.

  - Branching and Merging: A (remote) repository can have multiple branches, facilitating parallel development.


There are two routes to initialise a repository:

1. Use `git init`: starting a new project

Once you are within the directory of which you want to keep track, we use the `git init` command to create a new repository.
It sets up all necessary files and directories that Git needs to keep track of things

```
git init my_new_project
```

2. Use `git clone`: working on an existing project
`git clone` is used to copy an existing Git repository from a remote server to your local computer. 
This is how you get a project someone else (or you) has started so you can work on it.

```
git clone https://github.com/username/project.git
```


## Making changes

Making changes is at the core of version control, and Git excels at tracking these modifications.

A typical workflow involves the following steps:

- editing files
- staging changes
- committing, and optionally
- pushing them to a remote repository.

### Editing files
changes to files can be made using any text editor, such as VS Code, or integrated development environment (IDE), such as R studio.

You can use `git diff` to show the differences between the working directory and the staging area.

```
git diff [file name]
```

Highlights the differences for a specific file, and 

```
git diff .
```

Shows differences in all files that you have changed.

### Staging (and unstaging) Changes
Once you are happy with the changes you made, we will be preparing changes for a commit.

```
git add [file name]
```
Just like `git diff`, we can also use `git add .` to add all changes to the staging area.

If you are accidentally added the wrong file to the staging area, we can revert that by

```
git restore --staged [filename]
```
This step does not remove any changes you have just made to the file. 
Think of it as the opposite of `git add`.

### Committing Changes

Committing is the process of saving staged changes along with a descriptive message.
Remember a commit will, for better or worse, generate a record with a unique identifier in the history.
This is a irreversible process.

```
git commit -m "Descriptive message"

```
This creates a commit staged changes with a message.
You can also use `git commit` which opens a default text editor allowing the creation of longer commit message.

Once you have completed your commit, you can use `git log` to view the commit history.

A useful tip for visually inspecting the branching structure is the following command

```
git log --oneline --graph --all
```

It displays the entire commit history of all branches in a compact, one-line format, 
and illustrates the branching and merging structure with a rudimentary coloured art graph.

### Understanding changes

At any point of your workflow (no matter whether you are editing, staging or about to commit),
you can use `git status` to check the status of changes in the working directory and staging area.
It is encouraged to check the status before every commit.

## Branching and merging

**Branching** is a way to create parallel lines of development within a project,
while **merging** combine these parallel lines.
This two methods enable you or the teams to work on different features or bug fixes simultaneously without affecting the main codebase.

### Understanding branches

![](https://www.perforce.com/sites/default/files/image/2020-07/image-blog-git-branching-model.jpg)

1. creating branches:

```
git branch [branch-name]
```
This creates a new branch, *i.e.* a new 'copy' of the code to work on separately.

2. listing branches:

```
git branch
```
This allow you see all different 'copies' of lines of development locally.

3. switching between branches:

```
git checkout [branch-name]
```
This allows you to switch to a specific branch, and move between different parts of your project.
**Note** this will not work if you are in the middle of making changes.

Be sure to commit before switching to a specific branch as the content of your working directory will change depending on the branches.

4. deleting branches

```
git branch -d [branch-name]
```
this allows you to remove a branch that is no longer needed.
**Note** This will only remove any reference to the branch. 
Any history of the commits made previously will still exist.
Remember, once they are committed, there will be a mark of it in the log.

### The power of merging

- combining branches

```
git merge [branch-name]
```
This combines the specified branch with the current branch you are in.
Think of it as taking two separte pieces of writing and weaving them into one document.

- Dealing with conflicts:

Sometimes, changes in different branches may result in conflict.
If this is the case, the merging process will be halted temporarily by Git.
However Git will be (helpfully) highlight the conflicts and this must be manually resolved before attempting merge again.
We will discuss this further in a separate section.

## Pulling and Pushing Changes

the concepts of pulling (retrieving) and pushing (sending) changes between local and remote repositories
are foundational for collaborating with other team members, keeping everyone's work in sync.

### Setting Up Remote Repositories
A remote repository is a version of your project hosted on the internet or network, facilitating collaboration.
If you are working on an existing project by `git clone`, you can verify that a remote has been set up correct as follow:

```
git remote -v
```

- Create a remote repository
This can be done on platforms like GitHub, GitLab, Bitbucket, etc. 
When you create the repository on one of these platforms, it will provide you with a URL for the repository.

- Adding a remote repository
To add a new remote, use the `git remote add` command on the terminal, in the directory your repository is stored.

```
git remote add [remote-name] [URL]
```
Adds a remote repository with a specified name and URL (e.g., on GitHub). 
A common remote name is `origin`.
Once the remote repository is added, we can proceeed with the push/pulling.


### Pulling changes

Pulling is the process of fetching updates from a remote repository and merging them into your local repository.
This is mostly used when team members make changes to the shared codebase, pulling ensures that you have the latest version.

```
git pull [remote-name] [branch-name] --rebase
```

This fetches changes from the specified remote repository and branch and merges them into your local branch.
The commonly used `--rebase` option will rearrange the commits to make it look like everything happened in a linear orderly fashion.

Imagine you and a co-author are writing chapters of a book simultaneously. 
You both have a copy of the original manuscript, and you're both adding to it.
You finish your chapter and want to add it to the book, but you discover that your co-author has already added a new chapter.
Instead of simply inserting both chapters, you carefully weave your co-author's chapter into the book first, as if it were always there, and then add your chapter on top of it. 
To anyone reading the book, it appears as though the chapters were written in a perfect sequence, with no indication of the separate work.

### Pushing changes
Pushing is the process of sending your local changes to a remote repository so that others can access them.
Pushing allows you to share those updates with the team when you've made changes to the code.


```
git push [remote-name] [branch-name]
```
This sends your local changes to the specified remote repository and branch.

**Note** If it is your first time pushing the branch to a remote repository,
remember to use `--set-upstream` or `-u` to establish a tracking relationship between the local and remote branches.

```
git push -u [remote-name] [branch-name]
```

---
*Note*: common best practices is to ensure pulling the latest changes before pushing to avoid conflicts.

## Conflict Resolution

Conflicts occur when two branches have conflicting changes that Git cannot reconcile automatically.
This could happen during the merge of two local branches, or when changes in a remote branch is being pulled locally.
Your ability in resolving merge conflicts is essential for collaboration and code integrity.

Let's consider a simple scenario where two developers are working on different branches of the same project, and they both make changes to the same line of a file named example.txt.
This is a common situation that can lead to a merge conflict.

Original content of `example.txt` (on `main` branch)

```
Welcome to our project!
Please contribute to this file.
Thank you for collaborating.
```

Developer A decided to change (on `feature-a` branch) the second line to:

```
Please contribute to this file with new ideas.
```
Meanwhile, developer B decided to change (on `feature-b` branch) the second line to:

```
Please contribute by following our guidelines.
```

Both Developer A and Developer B made changes to the same line in their respective branches.
If Developer A merges their changes to main first, and then Developer B attempts to merge their changes, Git will not know which change to accept, leading to a merge conflict.

```
$ git pull origin feature-b #or git merge feature-b feature-a
CONFLICT (content): Merge conflict in example.txt,

Automatic merge failed; fix conflicts and then commit the result.

```

### Conflicts in Git
When Developer B attempts to merge, they might see a conflict like this in `example.txt`:

> ```
> Welcome to our project!
> <<<<<<< HEAD
> Please contribute to this file with new ideas.
> =======
> Please contribute by following our guidelines.
> >>>>>>> feature-b
> Thank you for collaborating.
> ```

The conflict markers `(<<<<<<<, =======, >>>>>>>)` delineate the conflicting changes.
The text between `<<<<<<< HEAD` and `=======` shows Developer A's changes (already merged into main), 
while the text between `=======` and `>>>>>>> feature-b` shows Developer B's changes on their `feature-b` branch.

### Example Resolution

To resolve this conflict, Developer B must manually edit the file to choose one of the changes or combine them as needed, remove the conflict markers, and then save, add, and commit the resolved file.

A resolved version might look like this:

```
Welcome to our project!
Please contribute to this file with new ideas and by following our guidelines.
Thank you for collaborating.
```
After the changes are made, you can carry on and repeat with your merging workflow as mentioned in the previous sections.

##  Popular Git Workflows

It is important to select an appropriate Git workflow prior to the start of any project to enhance collaboration and streamline development.

There are two popular git workflows which we will highlight below.

### Github flow

![](http://andersenlab.org/dry-guide/2022-03-09/img/github_flow.png){width=80%}

GitHub Flow is a lightweight, branch-based workflow.

In terms of branching strcture, typically only the main and feature branches are used. 
The main steps are outlined as follow:

- Sync with remote: Pull from the remote repository before beginning any work
- Create a Branch: Start a new branch for each new feature or bug fix.
- Commit Changes: Commit work to this branch locally.
- Open a Pull Request: Submit changes for review.
- Review & Merge: After review, merge changes into the master branch.

In essense, the main branch is always live and up-to-date with the latest feature.
It is best for small teams or projects that do not require a heavy structure as it allows for continuous development.

### Gitflow
![](https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fgitbook.tw%2Fimages%2Ftw%2Fgitflow%2Fwhy-need-git-flow%2Fflow.png){width=80%}

Gitflow, on the other hand, is a more rigid, rule-based workflow.
It makes use of delicate branches, for example, master, develop, feature, release, and hotfix, to create well-defined phases of development
Possible steps to create this workflow:

- Develop & Feature Branches: Continuous development occurs here, just like the Github flow
- Release Branches:  The develop branch gets merged to release once `develop` has acquired enough features.
- Main Branch: This branch reflects the official release history with version tag.
- Hotfix Branches: Quick fixes to live releases, usually from the main.

This is a rather grand workflow and hence it is suitable for larger teams and more complex projects.
It is ideal for a project that has defined stages of development and release.

### Practical tips and best practices

- Choosing the right workflow

    - **Assess Your Project**: It's essential to evaluate the unique characteristics of your project, including team size, complexity, release cycle, and specific requirements, to select the most suitable workflow.
    - **Flexibility vs. Structure**: Consider your team's need for flexibility or structure. 
    - **Customization**: Every project is different, and sometimes a one-size-fits-all approach might not be the best fit. 
    Don't hesitate to adapt or even combine aspects of different workflows to create a process that aligns with your team's needs and project goals.

- Common Guidelines and Practices

    - **Clear Communication**: Regardless of the workflow chosen, maintaining clear and open lines of communication among team members is crucial. 
    Regular updates and discussions can prevent misunderstandings and conflicts, ensuring that everyone is aligned with the project's direction and status.
    - **Documentation**: Having well-documented guidelines for the chosen workflow helps ensure that all team members understand the process and expectations. 
    This includes not only the technical aspects of branching, merging, and releasing but also the collaboration practices such as code review and issue tracking.
    - **Consistency**: Applying the chosen workflow consistently across the project helps in establishing a rhythm and makes it easier for team members to collaborate. 
    Consistency aids in minimizing confusion and enables more efficient progress tracking.
    - **Regular Review and Adaptation**: Workflows are not set in stone. 
    Regularly reviewing how the current workflow is serving the project and being open to adjustments as needed allows the team to respond to changing requirements or challenges effectively.    

Here are some common practices that could help you with your daily Git activities:

  - **Commit Messages**: Descriptive and Concise: Writing clear and descriptive commit messages helps in understanding the changes made. 
  A good practice is to start with a brief summary followed by a more detailed explanation if necessary.
  - **Standardized Branch Naming**: Adopting a standard naming convention for branches (e.g., feature/, bugfix/, hotfix/) ensures clarity and helps in tracking the purpose of each branch.
  - **Frequent Syncing with Main Branch**: Avoid Large Divergence: Regularly pulling changes from the main or base branch helps in keeping feature or development branches up to date, minimizing the risk of conflicts.
  - **Tagging Releases**: Utilizing tags to mark release versions provides a clear history of the project's progression and allows for easy navigation to specific points in the project's lifecycle.

## Leveraging Graphical Tools

In practice, there are graphical tools can simplify complex Git operations, providing a more intuitive and visual approach.
In this section, we will brieftly look into VS Code. It comes with built-in Git integration, offering a user-friendly interface for common Git tasks.

You can find detailed tutorials for common Git tasks [here](https://vscode.github.com/) with video explanation.

### Built-In Git Features in VS Code

- Source control panel
- Diff Viewer
- Git History and logs
- Integration extensions

## Resources & Further Learning

### Links to Tutorials

Provide links to tutorials, documentation, etc.

### Additional Resources

Recommend books, courses, etc.


